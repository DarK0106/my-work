package com.test.java;

public class Ex11_Casting
{
	public static void main(String[] args)
	{
		
		// Ex11_Casting.java
		/*
		 * 
		 * 형변환, 자료형 변환
		 * - Casting, Promotion 등 ..
		 * - 하나의 자료형을 다른 자료형으로 변환하는 작업
		 * - 하나의 자료형을 가진 데이터가 존재하는데 그걸 다른 자료형을 가진 데이터로 바꾼다
		 * - int 를 double 로 바꾼다
		 * - float -> short
		 * - 자유롭진 않고 전제가 있음, 숫자형끼리만 가능함
		 * 
		 * 1. 암시적 형변환, 자동 형변환 -> Promotion
		 *  - 큰 자료형 = 작은 자료형 -> 형변환은 발생하지만 눈에는 안 보임
		 *  - 왜 생략을 하게끔 해놨느냐 ?
		 *  - 예를 들어서 byte를 short로 바꾸는건 무슨 짓을 해도 안전하기 때문
		 *  - byte -> ㅁ한칸, short -> ㅁㅁ두칸 이라 뭘 해도 안전함
		 * 
		 * 2. 명시적 형변환, 강제 형변환 -> Casting
		 * 	- 작은 자료형 = 큰 자료형
		 * 	- 오버플로우(Overflow) 큰거에서 작은거로 옮길때 데이터가 넘쳐져서 넘친 부분은 버려짐
		 * 	- 값이 최솟값보다 낮아지면 언더플로우(Underflow) -> 오버플로우, 언더플로우 주의 !
		 */
		
		// 대입 연산자
		// Lvalue = Rvalue 오른쪽에 있는 값을 왼쪽에 있는 값에 저장하는 것
		// Lvalue(변수) = Rvalue(변수, 상수) 둘 다 값을 의미
		// 아주 중요한 규칙 -> Lvalue와 Rvalue의 자료형은 반드시 같아야 한다.
		
		// 암시젹 형변환 예시
		byte b1; // 길이(1바이트)
		short s1; // 길이 (2바이트)
		
		b1 = 100;
		
		// 왼쪽이 short 고 오른쪽이 byte
		// 원래 이상해야하는데 문제 없음
		// 그 이유는 숨겨져있는게 있음
		s1 = b1;
		// s1 = (short)b1;
		// (short)b1, 즉 (자료형)값 -> 이걸 형변환 연산자라고 부름
		// 이걸 암시적 형변환이라고 함
		
		// 명시적 형변환 예시
		byte b2;
		short s2;
		
		s2 = 100;
		
		// byte = short
		// 1바이트 = 2바이트
		// 작은 자료형 = 큰 자료형 
		
		// b2 = s2; 이렇게 하면 에러남
		b2 = (byte)s2; // 이건 직접 앞에 (byte) 쳐줘야함
		// s2에 들어가 있는 값에 따라 안전하게 복사될 수 있고 아닐 수 있어서
		// 작성한 개발자한테 책임을 전가하는 것 -> 너 스스로 인식을 하고 작업해
		System.out.println(b2); // 잘 복사가 됐는지는 복사본을 확인
		// byte니깐 127까진 안전하게 복사됨 128부터 이상해짐 문제는 에러가 안나고 값만 이상해서 뭐가 문젠지 찾기가 힘듬
		
		// 예) 국민은행 -> 계좌
		int m1; // 대치동점
		long m2; // 역삼동점
		
		m2 = 30000000000L; // 30억 계좌
		
		// 계좌 이체를 하려는데
		// 역삼동에서 대치동으로
		
		// m1 = m2; <- 에러남 왼쪽은 4바이트짜리 오른쪽은 8바이트짜리

		m1 = (int)m2;
		
		System.out.printf("이체 결과: %d원\n", m1); // 안전하게 복사가 안되서 값만 이상해짐
	}
	
}
