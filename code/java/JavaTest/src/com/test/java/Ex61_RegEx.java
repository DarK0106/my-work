package com.test.java;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.stream.events.Namespace;

public class Ex61_RegEx
{
	public static void main(String[] args)
	{
		// Ex61_RegEx.java
		/*
		 * 
		 * 정규 표현식, Regular Expression
		 * - 정규식
		 * - 자바(X) -> 독립된 표현식
		 * - "특정 패턴"을 가지는 문자열을 검색하는 도구
		 * 
		 * 정규 표현식을 구성하는 요소 -> 문법이라고 부름
		 * 
		 * 1. x
		 * 	- x는 임의의 문자 1개를 말한다
		 * 	ex) a는 내가 찾고자 하는 문자
		 * 	ex) abc라고 적으면 이게 정규표현식이고 abc를 찾아준다
		 * 	검색어를 넣으니까 검색어대로 검색해준다
		 * 
		 * 2. .
		 * 	- . 도 임의의 문자 1개를 말함(와일드카드라고 부름(wildcard), 조커 카드 느낌)
		 * 	ex) . -> 어떤 문자던 상관없이 1글자를 찾아주세요
		 * 	ex) .. -> 어떤 문자던 상관없이 2글자를 찾아주세요
		 * 	ex) a.c -> a도 진짜 글자, c도 진짜 글자, . 은 글자 아무거나 상관없어요
		 * 	a.(아무거나)c
		 * 	ex) a2c, a가c, axc ...
		 * 	ex) a..c <- abbc, acdc, aegc, a가나c, a12c
		 * 
		 * 우리가 사용하는 대부분의 편집기의 검색기에는 정규표현식 옵션이 있다
		 * 메모장엔 없는듯
		 * 
		 * 3. 출현횟수
		 * 	- 바로 앞에 있는 문자나 집합에 대해서 출현 횟수를 제한함
		 * 
		 * 	3.1 생략(아무것도 안 적음)
		 * 	- 바로 앞에 있는 문자나 집합의 출현 횟수가 생략될 수 없고, 중복될 수 없다
		 * 	- 출현 횟수: 1
		 * 
		 * 
		 * 	3.2 ?
		 * 	- 바로 앞에 있는 문자나 집합의 출현이 생략될 수 있지만, 중복할수는 없다
		 * 	- 출현 횟수: 0~1
		 * 	ex) a?bc 로 찾으면 abc, bc, abbc, acb, adc, adbc, abccde
		 * 	ex) 홍?길동 -> 안녕~ 길동아~ 네 이름이 홍길동이지?
		 * 	ex) 홍길?동 -> 안녕~ 길동아~ 네 이름이 홍길동이지? 홍동
		 * 	ex) 홍길동? -> 안녕~ 길동아~ 네 이름이 홍길동이지? 홍길
		 * 
		 * 	ex) 자바?코드 -> 자바코드가 있습니다. 그런데 그 코드에 에러가 있어요. 자코드
		 * 
		 * 
		 * 	3.3 +
		 * - 바로 앞에 있는 문자나 집합의 출현을 생략할 수 없고, 중복할수는 있다.
		 * - 출현 횟수: 1~무한대
		 * 	ex) a+bc 로 찾으면 abc, bc, abbc, acb, adc, adbc, abccde, aaaabc, aaaaaaaaaaaaabc
		 * 	ex) 홍+길동 -> 안녕~ 길동아~ 네 이름이 홍길동이지? 홍홍길동 홍홍홍홍홍홍홍홍길동
		 * 	ex) 자바+코드 -> 자바코드가 있습니다. 그런데 그 코드에 에러가 있어요. 자코드 자바코드 자바자바자바자바자바코드
		 * 
		 * 
		 * 	3.4 *
		 * - 바로 앞에 있는 문자나 집합의 출현을 생략이 가능하고, 중복도 가능하다.
		 * - 출현 횟수: 0~무한대
		 * 	ex) a*bc 로 찾으면 abc, bc, abbc, acb, adc, adbc, abccde, aaaabc, aaaaaaaaaaaaabc
		 * 	ex) 홍*길동 -> 안녕~ 길동아~ 네 이름이 홍길동이지? 홍홍길동 홍홍홍홍홍홍홍홍길동
		 * 	ex) 자바*코드 -> 자바코드가 있습니다. 그런데 그 코드에 에러가 있어요. 자코드 자바코드 자바자바자바자바자바코드
		 * 
		 * 
		 * 4. 선택, Choice
		 * 	- [] 안에 문자 여러개가 적혀있다. 그 문자들 중 딱 한개만 선택해라
		 * 	4.1 [값]
		 * 		ex) [012] -> 제 나이는 12살입니다. 제 동생은 11살이에요. 제 키는 160cm입니다. 몸무게는 51kg입니다.
		 * 		ex) [0 또는 1 또는 2] 를 찾아주십시오
		 * 		ex) [나생은] -> 제 나이는 12살입니다. 제 동생은 11살이에요. 제 키는 160cm입니다. 몸무게는 51kg입니다.
		 * 		ex) [홍김최정박]길동 -> 홍길동, 아무개, 하하하, 김길동, 최길동, 정길동, 박길동, 길동
		 * 		ex) [홍김최정박]?길동 -> 홍길동, 아무개, 하하하, 김길동, 최길동, 정길동, 박길동, 길동, 홍홍길동, 홍정길동
		 * 		ex) 연속된 숫자를 찾고싶다: [0123456789]+, [6574839201]+
		 * 		ex) 짝수만 찾고 싶다: [0123456789]*[02468] 12 24 15 23 18 50 27 48 69 52 74 55
		 * 		ex) 홀수만 찾고 싶다: [0123456789]*[13579] 12 33 13 15 19 24 15 23 18 50 27 48 69 52 74 55
		 * 		ex) 주민등록번호를 찾고싶어요 -> 991028-1234567
		 * 										 010530-2098765
		 * 			정규표현식:
		 * 			[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]-[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]
		 * 		
		 * 		ex) 전화번호를 찾고싶어요 ->
		 * 			010-1234-5678
		 * 			010-567-9876
		 * 			011-1234-5678
		 * 			016-9876-4956
		 * 			019-4374-3423
		 * 
		 * 			정규표현식:
		 * 			01[0169]-[0123456789]?[0123456789][0123456789][0123456789]-[0123456789][0123456789][0123456789][0123456789]
		 * 
		 * 		ex) 영어 소문자로만 이루어진 단어를 찾고 싶어요 ->
		 * 			[abcdefghijklmnopqrstuvwxyz]+
		 * 		ex) 영어 대문자로만 이루어진 단어를 찾고 싶어요 ->
		 * 			[ABCDEFGHIJKLMNOPQRSTUVWXYZ]+
		 * 			JAVA ORACLE java oracle
		 * 
		 * 		ex) 대, 소문자 상관없이 영어 단어를 찾고 싶어요 ->
		 * 		[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]+
		 * 		
		 * 		문제) 정규식 쓰기 쉽지않음
		 * 		저는 한글을 찾고싶어요 <- 11172개 써야됨
		 * 
		 * 		*[]에서 연속된 문자(코드)를 간단하게 표현하는 방법
		 * 		ex) 숫자를 찾고싶어요 -> [0123456789] -> [0-9] <- 범위로 지정할 수 있음
		 * 		ex) [0-9]+ <- 1자리 이상의 숫자 찾아줌(연속된 숫자)
		 * 		ex) 짝수를 찾고싶어요 -> [02468]임 [0-8] <- 이렇게 쓰면 사고남 이건 [012345678]임
		 * 		ex) 0123중에 하나 789 중에 하나 있는 숫자를 찾고 싶어요 -> [0123789] = [0-37-9]
		 * 		ex) 숫자 -> [036789] = [036-9]
		 * 		ex) 모든 영어 소문자를 찾고 싶어요 -> [a-z]
		 * 		ex) 모든 영어 대문자를 찾고 싶어요 -> [A-Z]
		 * 		ex) 모든 영어를 찾고 싶어요 -> [A-Za-z] 대문자가 문자코드 65로 시작하고 소문자가 97로 시작함
		 * 		그렇다고 [A-z] 이렇게 쓰면 사고남 대문자랑 소문자 사이에 글자 6개 더 있음 그것도 검색되는거임
		 *      <- 평상시에 타이핑하는 글자는 아니지만 그러면 안됨
		 *      
		 *      ex) 한글을 찾고싶어요 -> [가-힣]+ <- 연속된 한글자이상의 한글만 찾아라
		 *      	가, 강, 각, ㄱ, ㄲ, 강 <- 자음은 못찾음
		 *      
		 *      	ㅅㄱ -> 수고, 사과
		 *      	[사-싷][가-깋] <- 원래 이렇게 하는데 이클립스에서 안되는듯?
		 *      
		 *    	ex) 주민등록번호 찾을래요 -> [0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9]
		 *    	ex) 홍씨 성을 가진 사람을 찾고싶어요 -> 홍길동, 홍준식, 홍날두, 홍메시, 홍지성, 홍흥민, 홍르스타펜
		 *    		홍[가-힣][가-힣][가-힣]?
		 *    
		 *    	ex) 영문자 + 숫자 -> [A-Za-z0-9]
		 *    	ex) 영문자 + 숫자 + 한글 -> [A-Za-z0-9가-힣]
		 *    
		 *    	ex) 식별자로 적합한 문자로만 구성된 단어
		 *    		- 영어 + 숫자 + _
		 *    		- 숫자로 시작하면 절~~~대안됨
		 *    
		 *    		[A-Za-z_][A-Za-z0-9_]+
		 *    
		 *    		hong, hong123, hong123test, _test, 123hong(이게 검색되면안됨), test
		 * 									
		 * 
		 * 	4.2 [^값]
		 * 		- 4.1의 반대(부정형)
		 * 		- 나열된 값을 빼고 나머지를 다 찾아라		
		 * 
		 * 		ex) [0-9]+ <- 0에서부터 9까지 연속된 숫자를 찾아라(= 숫자를 찾아라)
		 * 		ex) [^0-9]+ <- 그거 빼고 나머지를 다 찾아라(= 숫자 빼고 다 찾아라)
		 * 		잘안씀
		 * 
		 * 	5. 출현횟수
		 * 		- 바로 앞의문자(집합)의 출현횟수를 표현
		 * 		- (생략, ?, +, *) -> 더 세밀한 패턴을 지정 가능
		 * 
		 * 		5.1 {n}
		 * 			- n : 출현횟수
		 * 			ex) a{1}bc <- a 출현횟수 무조건 1회 ab, bc, abc, ac, abbc, abcc, aabc, aaabc
		 * 			ex) a{2}bc <- a 출현횟수 무조건 2회 ab, bc, abc, ac, abbc, abcc, aabc, aaabc
		 * 			ex) a{3}bc <- a 출현횟수 무조건 3회 ab, bc, abc, ac, abbc, abcc, aabc, aaabc
		 * 
		 * 		5.2 {n,m}
		 * 			- n : 최소 출현 횟수
		 * 			- m : 최대 출현 횟수
		 * 			ex) a{1,2}bc -> ab, bc, abc, ac, abbc, abcc, aabc, aaabc			
		 * 			ex) a{2,3}bc -> ab, bc, abc, ac, abbc, abcc, aabc, aaabc			
		 * 			ex) a{0,1}bc == a?bc			
		 * 
		 * 		5.3 {n,}
		 * 			- n : 최소 출현 횟수
		 * 			- m 생략 : 무한대
		 * 			ex) a{1,}bc == a+bc
		 * 			ex) a{0,}bc == a*bc
		 * 			ex) a{0,1}bc == a?bc
		 * 
		 * 		ex) 주민등록번호 찾아주세요
		 * 			[0-9]{6}-[0-9]{7}
		 * 
		 * 		ex) 전화번호를 찾고싶어요
		 * 			010-[0-9]{3,4}-[0-9]{4}
		 * 
		 * 		ex) 홍씨 성을 갖는 이름(1~5글자)
		 * 			홍[가-힣]{1,5}
		 * 
		 * 
		 * 	6. 처음과 끝
		 *  	- 입력 컨트롤 또는 입력값 등을 대상으로 적용
		 *  	6.1 ^
		 *  		- ^ 뒤에 나와있는 표현으로 반드시 시작해야합니다
		 *  		ex) ^홍[가-힣]{2,3} -> 홍길동 홍길철수 홍순희 홍아지
		 *  		- str.startsWith("홍")
		 *  
		 *  
		 *  	6.2 $
		 *  		- $ 앞에 나와있는 표현으로 반드시 끝나야합니다
		 * 			- str.endsWith("동")
		 * 
		 * 	
		 * 	7. 줄임표현
		 * 		7.1 \d, \D
		 * 			- 왜 d냐? Digital(숫자)
		 * 			- [0-9] == \d 숫자들만 찾겠다
		 * 			- [^0-9] == \D 숫자들만 빼고 나머지를 다 찾겠다
		 * 
		 * 			ex) 주민등록번호 -> [0-9]{6}-[0-9]{7} == \d{6}-\d{7}
		 * 
		 * 		7.2 \w, \W
		 * 			- Word -> 영어 대소문자 + 숫자 + _ <- 식별자
		 * 			ex) [A-Za-z0-9_]{2,5}
		 * 			ex) \w{2,5}
		 * 
		 * 			ex) [^A-Za-z0-9_]{2,5} = \W{2,5}
		 * 
		 * 
		 * 		7.3 \s, \S
		 * 			 - 공백 문자(스페이스, 엔터, 탭)
		 * 			 ex) \s+ <- 공백만 찾을게요
		 * 			 ex) \S+ <- 공백만 빼고 나머지 다 찾을게요
		 * 
		 * 	정규식 만드는건 쉬움
		 * 	직접 사용할 때 내가 원하는 패턴이 뭔지 몰라서 힘들다
		 * 
		 * 	이메일?
		 * 	- 아이디@도메인
		 * 	- 아이디는 어떤 패턴을 가짐?
		 * 	- 도메인은 어떤 패턴을 가짐?
		 * 
		 * 	^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ // 이메일 검색 정규표현식
		 * 	
		 * 	test@gmail.com
		 * 	test.aaaa2222@gmail.com
		 * 	_aaa+bbb@daum.net
		 * 
		 */
		
		// m1();
		// m2();
		// m3();
		// m4();
		m5();
		
	}

	private static void m5()
	{
		String txt = " 출석 체크합니다. 홍길동~ 김길동~ 박길동~ 최길동~ 이길동~ 남궁길동~ 남길동~ 궁길동~ 길동~";
		
		// 요구사항) 모든 길동이 찾기
		// 성: 홍, 김, 박, 최, 이, 남궁, 남, 궁
//		String regex = "[홍김박최이남궁]길동"; // choice는 한글자씩 모아둔것
//		String regex = "[홍김박최이남궁]{1,2}길동"; // 잘못된 방법
		String regex = "(홍|김|박|최|이|남궁)길동"; // | (or) 로 구분할것, 여러 글자를 choice할때 사용하는 방법
		Pattern p1 = Pattern.compile(regex);
		Matcher m1 = p1.matcher(txt);
		
		while (m1.find())
		{
			System.out.println("결과: " + m1.group());
			System.out.println("성: " + m1.group(1)); // choice도 하는 겸 소괄호다 보니 그룹으로 묶였음, 마침 그룹이 성을 모아둔 그룹임
			System.out.println();
		}
		
		
	}

	private static void m4()
	{
		// String txt = "문자열";
		
		
		// Text Block -> JDL 15부터
		// 엔터 칠 수 있음
		String txt = """
				[서울경제]

점심 한 끼 가격이 1만원을 넘나드는 시대에 직장인들의 가장 큰 생활비 부담은 단연 식비다. 
고물가 흐름이 이어지면서 외식비가 가파르게 오르자 주변 구내식당을 찾는 사람들이 늘어나고 있다.

14일 간편 결제 서비스 업체 NHN페이코에 따르면 작umjunsik@naver.com년 하반기 수도권 주요 업무 지구 12곳의 직장인 평균 점심값은 1만1583원이었다. 
특히 강남(1만4000원), 여의도·서초(각 1만3000원) 등은 평균보다 2000~3000원 비쌌다. 점심값이 가장 비싼 곳은 대기업 본사가 밀집한 삼성동(1만5000원)이었다.

쌀국수 한 그릇에 1만5000원, 파스타 3만원 하는 시대. 고금리·고물가와 경기 한파가 계속dogisdog@gmail.com되면서 직장인들이 식비를 아끼려고 
점심 시간마다 전통시장이나 주변 구내식당으로 원정 식사에 나서고 있다.

시장조사기업 엠브레인 트렌드모니터가 전국 만 19~59세 직장인 남녀 1000명을 대상으로 실시한 '2025 직장인catbox@naver.com 구내식당 관련 인식 조사' 
결과에 따르면 현재 구내식당이 마련된 직장인의 이용 빈도는 매우 높았다. '거의 매일' 이용한다는 응답이 34.8%, '주 3~4회' 이용이 34.2%로, 
전체의 약 70%가 주중 대부분을 구내식당에서 해결하고 있었다. 이용 이유로는 '식비를 아낄 수 있어서'가 50.0%로 가장 많았고, '외부로 나가지 않아도 돼서'(46.6%), 
'점심시간을 절약할 수 있어서'(43.6%)가 뒤를 이었다.

이처럼 수요가 확대되면서 단체급식 업체들의 실적도 개선되고 있다. CJ프레시웨이는 3분기 누적 매출 2조5831억원으로 전년 대비 8.8% 성장했다. 
부문별 매출 성장률을 보면 급식식자재 15.6%, 단체급식 10.0%, 외식식자재 0.9% 수준이다.

삼성웰스토리와 현대그린푸드 역시 각각 7.0%, 2.1%의 매출 증가를 기록했다. 삼성웰스토리 관계자는 
“고물가에 급식 수요가 늘면서 급식 신규 사업장이 증가한 것이 실적에 영향을 미쳤다”고 설명했다. 
이 가운데 아워홈은 지난해 단체급식 시장 신규 입찰 물량의 약 30%를 수주하며 창사 이래 최대 신규 수주 실적을 달성했다. 
기존 고객과의 재계약률도 85%로 최근 5년 내 최고 수준을 기록했다.
				"""; // 마지막 쌍따옴표 기준으로 얘가 가진 탭까지는 공백을 적용하지 않음
		// System.out.println(txt);
		
		// 이메일 추출할 정규표현식 만들기
		String regex = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
		Pattern p1 = Pattern.compile(regex);
		Matcher m1 = p1.matcher(txt);
		
		while (m1.find())
		{
			System.out.println(m1.group());
		}
	}

	private static void m3()
	{
		// 정규식 클래스
		String txt = "안녕하세요. 홍길동입니다. 제 연락처는 010-1234-5678입니다. 혹시 이 번호로 연락이 안되면 010-5678-1234로 연락주세요.";
		
		// txt 안에 전화번호가 있는지?
		String regex = "([0-9]{3})-([0-9]{3,4})-([0-9]{4})";
		
		// 정규 표현식 객체를 만들자
		Pattern p1 = Pattern.compile(regex);
		
		// 검색 + 결과
		Matcher m1 = p1.matcher(txt);
		
		// 결과 확인
//		System.out.println(m1.find()); // 이미 찾은 값에 접근해 가져오는 find()
		// 찾으면 true 못찾으면 false
		
//		if (m1.find())
//		{
//			System.out.println("전화번호를 발견했습니다.");
//		}
//		else
//		{
//			System.out.println("전화번호를 발견하지 못했습니다.");
//		}
		
//		System.out.println(m1.find());
//		System.out.println(m1.find());
//		System.out.println(m1.find()); // 또 물어보면 갑자기 못찾았다고함
//		// iterator 같은 구조? 첫번째 find()는 첫번째 전화번호를 찾는다
//		//두번째 find()는 두번째 전화번호를 찾는다
//		//세번째 find()는 세번째 전화번호를 찾는다
//		// txt에 전화번호 2개밖에 없으니 세번째 find()는 찾을게없음
//		
//		// 전화번호 몇개?
//		int count = 0;
//		
//		while (m1.find()) // 처음부터 싹싹 찾음
//		{
//			count++;
//		}
//		
//		System.out.println("전화번호 총 개수: "+ count);
		
		while(m1.find())
		{
			System.out.println("[전화번호 발견]");
			System.out.println("전화번호: " + m1.group()); // 찾은 전화번호를 얻어와서 출력
			System.out.println("통신사: " + m1.group(1)); // ([0-9]{3})-[0-9]{3,4}-[0-9]{4} 에서 ()로 묶은 ([0-9]{3}) 가 1번째 그룹
			System.out.println("앞자리: " + m1.group(2));
			System.out.println("뒷자리: " + m1.group(3));
		}
		
		
	}

	private static void m2()
	{
		String names = "홍길동,아무개,강아지.고양이,병아리";
//		String list[] = names.split(",+"); // , 하나도 자르라는 뜻으로 생각하고 ,여러개가 나와도 자르라는 말로 알아라
		String list[] = names.split("[,\\.]+"); // , 하나도 자르라는 뜻으로 생각하고 . 도 그렇게 알아들어라
//		String list[] = names.split("[,\\.\\s]+"); // 공백도 구분자로 알아들어라
		// 근데 그냥 직접 수정을 해라 이런 상황에서 정규식 잘 안 씀
		
		for (String name : list)
		{
			System.out.println(name);
		}
		
		System.out.println("종료");
	}

	private static void m1()
	{
		// 자바
		// 1. 기존에 있던 여러 메서드들 중에 일부는 인자값으로 정규식을 지원한다
		// 2. 정규식 객체를 만들 수 있음, 그걸 사용해서 내맘대로 정규식 활용 가능

		// 게시판 글쓰기 -> 개인정보(전화번호)는 작성하지 말라고 적혀있음 <- 적어둔 개인정보를 강제로 마스킹해보자
		String txt = "안녕하세요. 홍길동입니다. 제 연락처는 010-1234-5678입니다. 혹시 이 번호로 연락이 안되면 010-5678-1234로 연락주세요.";
		
//		System.out.println(txt.replace("010-1234-5678", "XXX-XXXX-XXXX")); <- 어떻게 전화번호를 예측해서 코드를 씀? 말이 안됨
		
		System.out.println(txt.replaceAll("010-[0-9]{3,4}-[0-9]{4}", "XXX-XXXX-XXXX").replaceAll("010\\.[0-9]{3,4}\\.[0-9]{4}", "XXX-XXXX-XXXX")); // 전화번호 마스킹
		// 정규표현식에서 .가 의미가 있다보니 escape를 해야해서 \. 를 했는데 하필이면 자바에서 \ 가 문제가 되니 한번더 \를 붙여서 \\.가 되었음					
		
		System.out.println(txt.replaceFirst("010-[0-9]{3,4}-[0-9]{4}", "XXX-XXXX-XXXX")); // replaceFirst <- 처음 만난 애만 마스킹
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}
